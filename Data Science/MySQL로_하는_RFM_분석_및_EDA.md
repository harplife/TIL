Edited: 2021-09-30, 김우빈

# MySQL로 하는 RFM 분석 및 EDA

주문 데이터로 RFM 분석을 하는 방안에 대하여 간단히 설명 드립니다.

## RFM 분석이란?

RFM 분석은 행동 데이터를 통해 고객의 등급을 매기는 마케팅 분석 기법입니다.
여기서 __행동__은 방문, 클릭, 장바구니, 구매 등 고객이 쇼핑몰에 대하여 취할 수 있는 행동을 뜻 하며,
__등급__은 일반고객, 잠재고객, VIP, 휴면고객 등 쇼핑몰 관점에서 바라보는 고객의 성향을 뜻 합니다.

Recency, Frequency, Monetary의 약자로 RFM이라 불리며, 각 단어의 뜻은 __최근성, 반복성, 소비성__ 입니다.

이 3 가지 요소를 기준으로 고객의 행동을 수치화하여 고객의 등급을 판단하는게 RFM 분석입니다.

### Recency (최근성)

최근성이란 고객이 특정 행동을 얼마나 최근에 했는지를 의미합니다.

최근성 관점에서 고객의 가치를 판단할 경우, 최근에 행동을 취한 고객이 나중에 행동을 취한 고객보다 더 가치가 있을 수 있습니다.

예를 들어, 쇼핑몰로부터 1개월 전에 구매한 고객보다는 1일 전에 구매한 고객이 이 쇼핑몰에는 더 가치가 있을 수 있다는 것 입니다.

최근성을 계산하기 위해서 오늘 날짜(또는 데이터의 제일 최근 행동 날짜)와 각 고객 마지막 행동 날짜의 차를 구하면 됩니다.

### Frequency (반복성)

반복성이란 고객이 특정 행동을 얼마나 자주 했는지를 의미합니다.

반복성 관점에서 고객의 가치를 판단할 경우, 다른 고객보다 더 자주 구매한 고객이 보다 더 가치가 있을 수 있습니다.

예를 들어, 쇼핑몰로부터 3번 구매한 고객보다는 10번 구매한 고객이 이 쇼핑몰에는 더 가치가 있을 수 있다는 것 입니다.

반복성은 여러 방면으로 계산할 수 있습니다.

1. 총 주문 건수, 주문 상품 단위
   (예: 주문 A에 상품 2개, 주문 B에 상품 3개가 있는 경우 반복성은 5가 됩니다)
2. 총 주문 건수, 주문 단위
   (예: 주문 A, 주문 B, 반복성은 2가 됩니다)
3. 총 주문 건수, 1일 단위
   (예: 주문 A는 어제, 주문 B와 C는 오늘인 경우, 반복성은 2가 됩니다)
4. 주문 건수 평균, 한 달의 n개
   (예: 7월 달에 4개, 8월 달에 8개 구매한 경우, 반복성은 6이 됩니다)

위 예시는 반복성을 계산하는 방안 중 극히 일부이며, 쇼핑몰의 성향에 따라 맞출 필요가 있습니다.
쇼핑몰의 관점에서 한 번에 대량 구매하는 고객이 더 가치가 있는지, 또는 주기적으로 소량 구매하는 고객이 더 가치가 있는지, 그 외에 반복성에 속한 다른 변수가 있는지 고려해야 합니다.

가전제품 쇼핑몰 같이, 한번 구매하고 최소 2년 후까지 반복 구매가 없는 경우도 있습니다. 이와 같은 경우, 반복성이 의미가 있는지 고려해야 하고 무의미한 경우 RFM 분석에 제외하거나 변형하는게 좋습니다.

### Monetary (소비성)

소비성이란 고객이 특정 행동에 얼마나 소비 했는지를 의미합니다.
(__소비__란 돈이나 물자, 시간, 노력 등을 들이거나 사용하는 것을 뜻합니다)

소비성 관점에서 고객의 가치를 판단할 경우, 다른 고객보다 더 많은 소비를 한 고객이 보다 더 가치가 있게 되는 것입니다.

예를 들어, 쇼핑몰에 10만원을 소비한 고객보다 100만원 소비한 고객이 이 쇼핑몰에는 더 가치가 있을 수 있다는 것 입니다.

반복성과 유사하게, 소비성도 여러 방면으로 계산할 수 있습니다.

1. 총 결제 금액
   (예: 주문 A는 10만원, 주문 B는 20만원인 경우, 소비성은 30만원이 됩니다)
2. 평균 결제 금액
   (예: 주문 A는 10만원, 주문 B는 20만원인 경우, 소비성은 15만원이 됩니다)
3. 최대 결제 금액
   (예: 주문 A는 10만원, 주문 B는 20만원인 경우, 소비성은 20만원이 됩니다)

위 예시는 소비성을 계산하는 방안 중 극히 일부이며, 쇼핑몰의 성향에 따라 맞출 필요가 있습니다.

참고로, 소비성과 반복성은 선형관계를 이룰 수 가 있습니다. 그 말은, 반복성이 높을 수록 소비성이 같이 높을 수 있다는 것입니다.
예를 들어, 쇼핑몰의 모든 상품이 1000~2000원 사이인 경우, 단순히 총 주문 건수(반복성)와 총 결제 금액(소비성)을 분석하면 동일한 반복성을 가진 고객들의 소비성이 차이가 크게 나지 않기 때문에 분석에 큰 의미가 없게 됩니다.

## 분석 대상 데이터

이 가이드에서 사용되는 데이터는 고객이 쇼핑몰로부터 상품을 구매한 이력 정보가 담긴 주문 데이터 입니다.

주문 데이터 테이블 `masales3`의 각 행은 고객의 주문에 속하는 하나의 아이템이 됩니다.
예를 들어,

| 고객번호 | 주문번호 | 상품번호 |
| :------: | :------: | :------: |
|    A     |   a11    |   p421   |
|    A     |   a11    |   p565   |
|    B     |   b52    |   p227   |
|    B     |   b77    |   p227   |
|    C     |   c21    |   p421   |

고객은 여러 주문을 할 수 있고, 각 주문에 하나 이상의 상품이 속합니다 (N:N:N).

주문 데이터 테이블에는 고객번호, 주문번호, 상품번호 외에 고객에 대한 정보(성별, 회원가입 날짜 등)과 주문에 대한 정보(주문일자, 주문상태, 주문결제여부 등)이 있습니다.

총 데이터 개수는 930414 개이며, 인덱스를 포함하여 총 열의 개수는 94 개가 됩니다.

### 필수 데이터

RFM 분석에 필요한 필수 데이터는 다음과 같습니다.

- 고객번호 `CustomerId`
- 주문번호 `OrderNum`
- 상품번호 `ProductCode`
- 주문일자 `OrderDate`
- 결제금액 `PaymentReal`
- 구매확정여부 `PaymentReal > 0, StateCancel = '취소안함'`

### 데이터 정제

`masales3` 테이블에 필요한 부분만 불러옵니다.

하나의 쇼핑몰 `DatagroupId='912745836499727'` 에 속하며 1년치 `2015-07-08 <= OrderDate <= 2016-07-07` 데이터를 가져옵니다.

```mariadb
CREATE VIEW sales_data AS
  SELECT
    CustomerId, OrderNum, OrderDate, ProductCode, PaymentReal, StateCancel
  FROM masales3
  WHERE (PaymentReal > 0) # 결제 안한 경우 또는 무료인 경우는 배제함.
  AND (StateCancel) = '취소안함' # 주문 성공 여부는 취소가 안 된 경우까지만 봄. 부분취소는 반영이 안되서 약간 부족한 점이 있음.
  AND (DatagroupId='912745836499727') # 데이터의 소스. 하나의 쇼핑몰로 보면 됨.
  AND (CustomerId IS NOT NULL) # 고객고유번호
  AND (OrderNum IS NOT NULL) # 주문고유번호
  AND (ProductCode IS NOT NULL) # 상품고유번호 (없어도 됨)
  AND (OrderDate >= '2015-07-08 00:00:00') # 데이터 범위는 편의상 1년을 잡았음
  AND (OrderDate <= '2016-07-07 23:59:59')
  AND DelYN='N' # 삭제되지 않은 데이터만 취급
;
```

위 쿼리를 실행하면 `sales_data` VIEW 테이블이 생성됩니다.
테이블 행의 개수는 10083 개, 고객의 수와 동일합니다.

## RFM 분석 실행

가이드에서 사용한 RFM 분석 계산식은 다음과 같습니다.

- Recency = 데이터 기준 마지막 구매 일자 - 각 고객의 마지막 구매 일자
- Frequency = 각 고객의 총 구매 건수
- Monetary = 각 고객의 총 결제 금액

정제된 데이터, `sales_data` 테이블을 대상으로 RFM 분석을 합니다.

```mariadb
CREATE VIEW rfm_data AS
  SELECT
    t2.customer_id AS Customer,
    # 전체 기준 마지막 구매 일자에서 각 고객의 마지막 구매 일자 차이를 찾음
    DATEDIFF(t1.most_recent_date, t2.last_order_date) AS Recency,
    t2.count_order AS Frequency,
    t2.sum_price AS Monetary
  FROM (
    # 전체 데이터의 마지막 주문 일자 (NOW로 대체해도 됨)
    SELECT DATE(MAX(OrderDate)) AS most_recent_date FROM sales_data
  ) AS t1, (
    # 실제로 RFM 계산 하는 부분
    SELECT
      t.CustomerId AS customer_id,
      MAX(t.OrderDate) AS last_order_date, # 고객의 마지막 주문 일자
      COUNT(t.CustomerId) AS count_order, # 고객의 누적 주문 수
      SUM(t.PaymentReal) AS sum_price # 고객의 누적 주문 금액
    FROM (
      # 1차적으로 주문별로 정리함
      SELECT CustomerId, OrderDate, OrderNum, PaymentReal
      FROM sales_data
      GROUP BY OrderNum
    ) AS t
    # 2차적으로 고객별로 정리함
    GROUP BY customer_id
  ) AS t2
  ORDER BY Customer
;
```

위 쿼리를 실행하면 `rfm_data` VIEW 테이블이 생성됩니다.

테이블에는 4 개의 열, `Customer, Recency, Frequency, Monetary`가 있습니다.

## RFM 분석 결과 해석

### Recency 해석

Recency의 값이 낮을 수록 고객의 등급이 높아집니다.

Recency가 낮은 고객은 한 번 이상 구매하고 한동안 구매를 안 한 고객으로 판단되어 __잠재고객__으로 분류 할 수 있습니다.
잠재고객이 다시 쇼핑몰에 복귀할 수 있도록 유도하는 것이 마케터의 목표가 될 수 있습니다.
쇼핑몰 운영자는 고객이 왜 복귀를 안 하는지, 상품/서비스/사이트에 문제/특성 인지 파악하는게 목표가 될 수 있습니다.

### Frequency, Monetary 해석

Frequency와 Monetary는 값이 높을 수록 고객의 등급이 높아집니다.

Frequency가 높은데 Monetary가 낮은 고객은 대량으로 값싼 상품을 구매하는 고객으로 판단 되기 때문에, 이러한 고객에게는 좀 더 비싼 상품을 구매할 수 있도록 유도하는게 좋습니다.
예를 들어, 고객이 구매한 상품 A와 유사하되 좀 더 비싼 상품 B를 쿠폰으로 더 싸게 살 수 있게 하여 한번이라도 B를 구매하게 합니다.
이로서, 고객이 상품 B가 상품 A보다 좋다고 느끼게 되면 쿠폰이 없더라도 좀 더 비싼 상품인 상품 B를 구매할 확률이 높아집니다.

Frequency가 낮은데 Monetary가 높은 고객은 소량으로 값비싼 상품을 구매하는 고객으로 판단되어,
이러한 고객의 성향은 A) 돈을 모아 나중에 크게 소비하는 성향, B) 퀄리티에 신경쓰는 성향, 또는 C) 돈은 많지만 자산관리에 신중한 성향으로 분류할 수 있습니다. 각 성향에 맞추어 좀 더 상품을 자주 구매하도록 유도하는게 좋습니다.
예를 들어, 더 많은 금액을 소비할 수록 더 많은 해택을 받을 수 있도록 제도, 쿠폰, 이벤트 등을 제공하는 것도 일종에 방법입니다.

Frequency가 높고 Monetary도 높은 고객은 대량으로 값비싼 상품을 구매하는 고객으로 판단되어, 무조건 VIP 입니다.
VIP는 Recency가 낮아지지 않는지 자주 확인하고 낮아지면 그에 대응할 수 있도록 하는게 좋습니다.
실제 매출을 확인해보면 일반고객보다 VIP가 차지하고 있는 비율이 더 높을 수도 있습니다.
이러한 경우, VIP가 선호하는 상품 또는 그러한 계열의 상품을 더 진열하는게 좋습니다.

## RFM 스코어

RFM 분석은 연속적인 값이 나오기 때문에, 명확하게 등급을 구분하기 어려울 수가 있습니다.

"최근에 자주 구매하는 고객"을 분류한다면 - 이 "최근"은 Recency의 어떤 값까지 해당하는지, "자주"는 Frequency의 어떤 값까지 인정할지, 기준이 애매합니다.

RFM 스코어는 하나의 그룹을 순위대로 정렬한 후 n-등분함으로서 "상대적으로 적고 또는 많은" 값을 가진 하위 그룹들로 분별하는 방식을 사용합니다.

예를 들어, 1개 구매한 사람, 2개 구매한 사람, .. 10개 구매한 사람, 총 10명이 있다고 하고, 이 10명에 대하여 구매횟수에 따라 오름차순으로 정렬합니다. 그 후, 이 그룹에 대하여 차례대로 5 등분을 하면 각 2명씩의 하위 그룹이 나옵니다. 그룹 1은 1개, 2개 구매한 사람들, 그룹 2는 2,3개, .. 그룹 5는 9개, 10개 구매한 사람들이 있습니다. 그렇다면, 그룹 5는 상대적으로 "가장" 많이 구매하는 그룹으로 봅니다.

위 예시와 동일하게, RFM 스코어는 Recency, Frequency, Monetary 각 기준에 대하여 n-등분을 합니다.

이 가이드에서는 5 등분을 해봅니다.

3가지 요소를 기준으로 5 등분을 하면, R-F-M 전체를 기준으로 총 125 개의 등급이 나옵니다.

=> 1-1-1, 1-2-1, 1-3-1, ... , 5-5-3, 5-5-4, 5-5-5

참고로, 이 가이드에서는 등급 1이 제일 낮고, 등급 5가 제일 높은 값으로 취급합니다.
Recency는 값이 낮을 수록 등급이 높게, Frequency와 Monetary는 값이 높을 수록 등급이 높게 계산됩니다.

125 개의 등급은 많아 보일 수도 있지만, 아주 간단하게 보려면 4 이상의 등급은 VIP, 2~3 등급은 일반 고객, 1 등급은 이탈/휴면/잠재 고객으로 보면 되겠습니다. 또는, 밑에와 같이 등급 차트를 구성해볼 수 도 있습니다.

![RFM_SCORE_CHART](https://user-images.githubusercontent.com/44990492/135390125-a53e548f-559a-4f92-bb3c-668280d19f96.png)

RFM 스코어가 무엇이고 이를 통해 구분된 고객 등급을 어떻게 해석하는지 알아봤으니, 이제 직접 DB에서 계산해봅니다.

```mariadb
CREATE VIEW rfm_score AS
  SELECT
    Customer,
    NTILE(5) OVER (ORDER BY Recency DESC)  AS RecencyScore, # Recency 스코어
    NTILE(5) OVER (ORDER BY Frequency ASC) AS FrequencyScore, # Frequency 스코어
    NTILE(5) OVER (ORDER BY Monetary ASC)  AS MonetaryScore # Monetary 스코어
  FROM rfm_data;
```

위 쿼리를 실행하면 `rfm_score` VIEW 테이블이 생성됩니다.

Recency 스코어가 5, Frequency 스코어가 4~5 인 "챔피온" 그룹을 찾아보면,

```mariadb
SELECT COUNT(*) FROM rfm_score WHERE RecencyScore=5 AND FrequencyScore in (4,5);
```

총 1408 명이 챔피온 그룹인 것을 확인할 수 가 있습니다.
챔피온 그룹에게는 감사 말씀이라도 드려야 할까요?

위와 같이 RFM 스코어를 통해 고객을 세분화하고 그룹으로 합치고 각 그룹의 의미를 정의를 해봤습니다.
각 그룹에 대하여 좀 더 상세한 탐색적 분석(EDA)를 하면 각 그룹의 성향 (선호하는 상품, 연령대, 성별)을 파악할 수 있습니다.

이상입니다~

## 탐색적 데이터 분석

EDA (Exploratory Data Analysis, 탐색적 데이터 분석) 은 말 그대로 데이터를 탐색하는 과정입니다.
데이터의 평균이 어떻게 되는지, 최소값/최대값이 어떻게 되는지, 분포가 어떻게 되는지 등등에 통계를 내는 작업이 됩니다.

일단 편의상 Frequency를 대상으로 EDA를 진행합니다.

우선, 기본적으로 다음과 같은 통계를 내봅니다.

- 총 합 `total_sum`
- 최소 `minimum`
- 최대 `maximum`
- 평균 `mean`
- 표준 편차 `standard_deviation`

쿼리는 밑에와 같습니다.

```mariadb
SELECT
  SUM(Frequency) AS total_sum,
  MIN(Frequency) AS minimum,
  MAX(Frequency) AS maximum,
  AVG(Frequency) AS mean,
  STD(Frequency) AS standard_deviation
FROM rfm_data;
```

결과값은 밑에와 같습니다.

| total_sum | minimum | maximum | mean   | standard_deviation |
| --------- | ------- | ------- | ------ | ------------------ |
| 31521     | 1       | 69      | 3.1262 | 4.0584             |

총 합은 총 주문건수와 동일합니다.

최소 값은 1년 내에 1번만 구매한 고객이 있다는 뜻입니다.
이러한 고객은 최근에 처음으로 쇼핑몰에서 구매한 고객일 수도 있고, 또는 휴면/이탈 고객일 수도 있습니다.
좀 더 정확히 알아보려면 1번 구매한 고객들의 Recency를 기준으로 확인해봐야 합니다 (지금은 skip).

최대 값은 1년 내에 69번 구매한 고객이 있다는 뜻입니다.
이러한 고객은 짧은 기간 (하루, 한달) 동안 대량 구매를 했거나, 또는 1년 동안 주기적으로 자주 구매를 했을 수 있습니다.
좀 더 정확히 알아보려면 주문일자의 간격을 확인해봐야 합니다.

평균 값은 1년 내에 고객이 3번 정도 구매한다는 뜻이 될 수도 있습니다.
평균은 데이터 분포에 따라 의미가 있을 수도 있고 의미가 없을 수도 있습니다.
예를 들어, 1번 구매한 고객이 9명이고 20번 구매한 고객이 1명이면, 구매 횟수의 평균은 2.9가 됩니다.
즉, 보통 고객이 3번 정도는 구매한다는 뜻으로 오해할 수 가 있습니다.
이러한 오해를 방지하기 위해, 평균은 표준 편차와 같이 관찰합니다.

-- 진행중 --
